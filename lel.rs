# ! [ feature ( prelude_import ) ] # ! [ feature ( async_closure ) ] # [ prelude_import ] use std :: prelude :: v1 :: * ; # [ macro_use ] extern crate std ; use async_trait :: async_trait ; use futures :: executor :: block_on ; use quicksockets :: websocket :: Websocket ; use quicksockets :: Connection ; use quicksockets :: Message ; use quicksockets :: SocketCallback ; use quicksockets :: SslStream ; use quicksockets :: TcpStream ; use quicksockets :: { AsyncRead , AsyncWrite } ; use quicksockets :: { Request , Response } ; struct Test < T > where T : AsyncWrite + AsyncRead + Send { pub conn : Connection < T > , } impl < T > SocketCallback for Test < T > where T : AsyncRead + AsyncWrite + Unpin + Send { fn on_open < 'life0 , 'async_trait > ( & 'life0 mut self ) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = ( ) > + :: core :: marker :: Send + 'async_trait > > where 'life0 : 'async_trait , Self : 'async_trait { # [ allow ( clippy :: missing_docs_in_private_items , clippy :: used_underscore_binding , ) ] async fn __on_open < T > ( _self : & mut Test < T > ) where ( ) : Sized , T : AsyncRead + AsyncWrite + Unpin + Send { { :: std :: io :: _print ( :: core :: fmt :: Arguments :: new_v1 ( & [ "On open\n" ] , & match ( ) { ( ) => [ ] , } ) ) ; } ; } Box :: pin ( __on_open :: < T > ( self ) ) } fn on_close < 'life0 , 'async_trait > ( & 'life0 mut self , close_code : Option < u32 > , reason : String ) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = ( ) > + :: core :: marker :: Send + 'async_trait > > where 'life0 : 'async_trait , Self : 'async_trait { # [ allow ( clippy :: missing_docs_in_private_items , clippy :: used_underscore_binding , ) ] async fn __on_close < T > ( _self : & mut Test < T > , close_code : Option < u32 > , reason : String ) where ( ) : Sized , T : AsyncRead + AsyncWrite + Unpin + Send { { :: std :: io :: _print ( :: core :: fmt :: Arguments :: new_v1 ( & [ "Closed with reason: " , " and code: " , "\n" ] , & match ( & reason , & close_code ) { ( arg0 , arg1 ) => [ :: core :: fmt :: ArgumentV1 :: new ( arg0 , :: core :: fmt :: Display :: fmt ) , :: core :: fmt :: ArgumentV1 :: new ( arg1 , :: core :: fmt :: Debug :: fmt ) ] , } ) ) ; } ; } Box :: pin ( __on_close :: < T > ( self , close_code , reason ) ) } fn on_message < 'life0 , 'async_trait > ( & 'life0 mut self , frame : Message ) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = ( ) > + :: core :: marker :: Send + 'async_trait > > where 'life0 : 'async_trait , Self : 'async_trait { # [ allow ( clippy :: missing_docs_in_private_items , clippy :: used_underscore_binding , ) ] async fn __on_message < T > ( _self : & mut Test < T > , frame : Message ) where ( ) : Sized , T : AsyncRead + AsyncWrite + Unpin + Send { { :: std :: io :: _print ( :: core :: fmt :: Arguments :: new_v1 ( & [ "Got: " , "\n" ] , & match ( & frame . to_string ( ) , ) { ( arg0 , ) => [ :: core :: fmt :: ArgumentV1 :: new ( arg0 , :: core :: fmt :: Display :: fmt ) ] , } ) ) ; } ; let msg = Message :: new ( "Sent message" . into ( ) ) ; _self . conn . send ( msg ) . await . unwrap ( ) ; } Box :: pin ( __on_message :: < T > ( self , frame ) ) } } fn main ( ) { tokio :: runtime :: Builder :: new ( ) . basic_scheduler ( ) . threaded_scheduler ( ) . enable_all ( ) . build ( ) . unwrap ( ) . block_on ( async { { let mut socket = Websocket :: < SslStream , _ , _ > :: build ( "127.0.0.1:4545" , | x | Test { conn : x , } , "../indentity.pfx" ) . listen ( ) . await ; } } ) }